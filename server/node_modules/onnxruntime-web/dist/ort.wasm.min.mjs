/*!
 * ONNX Runtime Web v1.21.0-dev.20241205-d27fecd3d3
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Ne=Object.defineProperty;var yr=Object.getOwnPropertyDescriptor;var wr=Object.getOwnPropertyNames;var gr=Object.prototype.hasOwnProperty;var We=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var E=(e,t)=>()=>(e&&(t=e(e=0)),t);var $e=(e,t)=>{for(var n in t)Ne(e,n,{get:t[n],enumerable:!0})},br=(e,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of wr(t))!gr.call(e,r)&&r!==n&&Ne(e,r,{get:()=>t[r],enumerable:!(o=yr(t,r))||o.enumerable});return e};var st=e=>br(Ne({},"__esModule",{value:!0}),e);var ye,G,re,Er,it,Ge=E(()=>{"use strict";ye=new Map,G=[],re=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let o=ye.get(e);if(o===void 0)ye.set(e,{backend:t,priority:n});else{if(o.priority>n)return;if(o.priority===n&&o.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let r=G.indexOf(e);r!==-1&&G.splice(r,1);for(let a=0;a<G.length;a++)if(ye.get(G[a]).priority<=n){G.splice(a,0,e);return}G.push(e)}return}throw new TypeError("not a valid backend")},Er=async e=>{let t=ye.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(o){return n||(t.error=`${o}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},it=async e=>{let t=e.executionProviders||[],n=t.map(u=>typeof u=="string"?u:u.name),o=n.length===0?G:n,r,a=[],s=new Set;for(let u of o){let f=await Er(u);typeof f=="string"?a.push({name:u,err:f}):(r||(r=f),r===f&&s.add(u))}if(!r)throw new Error(`no available backend found. ERR: ${a.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:f}of a)n.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${f}`);let i=t.filter(u=>s.has(typeof u=="string"?u:u.name));return[r,new Proxy(e,{get:(u,f)=>f==="executionProviders"?i:Reflect.get(u,f)})]}});var at=E(()=>{"use strict";Ge()});var ut,ft=E(()=>{"use strict";ut="1.21.0-dev.20241205-6ed77cc374"});var ct,U,ze=E(()=>{"use strict";ft();ct="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:ut},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ct=e}},get logLevel(){return ct}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var S,dt=E(()=>{"use strict";ze();S=U});var lt,pt,mt=E(()=>{"use strict";lt=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let o=n.getContext("2d");if(o!=null){let r,a;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],a=e.dims[3]):(r=e.dims[3],a=e.dims[2]);let s=t?.format!==void 0?t.format:"RGB",i=t?.norm,u,f;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean=="number"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?f=[0,0,0,0]:typeof i.bias=="number"?f=[i.bias,i.bias,i.bias,i.bias]:(f=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(f[3]=i.bias[3]));let l=a*r,d=0,c=l,p=l*2,w=-1;s==="RGBA"?(d=0,c=l,p=l*2,w=l*3):s==="RGB"?(d=0,c=l,p=l*2):s==="RBG"&&(d=0,p=l,c=l*2);for(let m=0;m<a;m++)for(let y=0;y<r;y++){let A=(e.data[d++]-f[0])*u[0],h=(e.data[c++]-f[1])*u[1],g=(e.data[p++]-f[2])*u[2],O=w===-1?255:(e.data[w++]-f[3])*u[3];o.fillStyle="rgba("+A+","+h+","+g+","+O+")",o.fillRect(y,m,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},pt=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(n!=null){let r,a,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(r=e.dims[2],a=e.dims[1],s=e.dims[3]):(r=e.dims[3],a=e.dims[2],s=e.dims[1]);let i=t!==void 0&&t.format!==void 0?t.format:"RGB",u=t?.norm,f,l;u===void 0||u.mean===void 0?f=[255,255,255,255]:typeof u.mean=="number"?f=[u.mean,u.mean,u.mean,u.mean]:(f=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(f[3]=u.mean[3])),u===void 0||u.bias===void 0?l=[0,0,0,0]:typeof u.bias=="number"?l=[u.bias,u.bias,u.bias,u.bias]:(l=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(l[3]=u.bias[3]));let d=a*r;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!=="RGBA"||s===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let c=4,p=0,w=1,m=2,y=3,A=0,h=d,g=d*2,O=-1;i==="RGBA"?(A=0,h=d,g=d*2,O=d*3):i==="RGB"?(A=0,h=d,g=d*2):i==="RBG"&&(A=0,g=d,h=d*2),o=n.createImageData(r,a);for(let B=0;B<a*r;p+=c,w+=c,m+=c,y+=c,B++)o.data[p]=(e.data[A++]-l[0])*f[0],o.data[w]=(e.data[h++]-l[1])*f[1],o.data[m]=(e.data[g++]-l[2])*f[2],o.data[y]=O===-1?255:(e.data[O++]-l[3])*f[3]}else throw new Error("Can not access image data");return o}});var je,ht,yt,wt,gt,bt,Et=E(()=>{"use strict";we();je=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:o}=t,r=t.norm??{mean:255,bias:0},a,s;typeof r.mean=="number"?a=[r.mean,r.mean,r.mean,r.mean]:a=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?s=[r.bias,r.bias,r.bias,r.bias]:s=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let i=t.format!==void 0?t.format:"RGBA",u=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",f=n*o,l=u==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),d=4,c=0,p=1,w=2,m=3,y=0,A=f,h=f*2,g=-1;i==="RGB"&&(d=3,c=0,p=1,w=2,m=-1),u==="RGBA"?g=f*3:u==="RBG"?(y=0,h=f,A=f*2):u==="BGR"&&(h=0,A=f,y=f*2);for(let B=0;B<f;B++,c+=d,w+=d,p+=d,m+=d)l[y++]=(e[c]+s[0])/a[0],l[A++]=(e[p]+s[1])/a[1],l[h++]=(e[w]+s[2])/a[2],g!==-1&&m!==-1&&(l[g++]=(e[m]+s[3])/a[3]);return u==="RGBA"?new L("float32",l,[1,4,n,o]):new L("float32",l,[1,3,n,o])},ht=async(e,t)=>{let n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,o=typeof ImageData<"u"&&e instanceof ImageData,r=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a=typeof e=="string",s,i=t??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=l=>typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||l instanceof OffscreenCanvas?l.getContext("2d"):null;if(n){let l=u();l.width=e.width,l.height=e.height;let d=f(l);if(d!=null){let c=e.height,p=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(c=t.resizedHeight,p=t.resizedWidth),t!==void 0){if(i=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=c,i.width=p}else i.tensorFormat="RGBA",i.height=c,i.width=p;d.drawImage(e,0,0),s=d.getImageData(0,0,p,c).data}else throw new Error("Can not access image data")}else if(o){let l,d;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(l=t.resizedHeight,d=t.resizedWidth):(l=e.height,d=e.width),t!==void 0&&(i=t),i.format="RGBA",i.height=l,i.width=d,t!==void 0){let c=u();c.width=d,c.height=l;let p=f(c);if(p!=null)p.putImageData(e,0,0),s=p.getImageData(0,0,d,l).data;else throw new Error("Can not access image data")}else s=e.data}else if(r){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let l=u();l.width=e.width,l.height=e.height;let d=f(l);if(d!=null){let c=e.height,p=e.width;return d.drawImage(e,0,0,p,c),s=d.getImageData(0,0,p,c).data,i.height=c,i.width=p,je(s,i)}else throw new Error("Can not access image data")}else{if(a)return new Promise((l,d)=>{let c=u(),p=f(c);if(!e||!p)return d();let w=new Image;w.crossOrigin="Anonymous",w.src=e,w.onload=()=>{c.width=w.width,c.height=w.height,p.drawImage(w,0,0,c.width,c.height);let m=p.getImageData(0,0,c.width,c.height);i.height=c.height,i.width=c.width,l(je(m.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return je(s,i);throw new Error("Input data provided is not supported - aborted tensor creation")},yt=(e,t)=>{let{width:n,height:o,download:r,dispose:a}=t,s=[1,o,n,4];return new L({location:"texture",type:"float32",texture:e,dims:s,download:r,dispose:a})},wt=(e,t)=>{let{dataType:n,dims:o,download:r,dispose:a}=t;return new L({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:o,download:r,dispose:a})},gt=(e,t)=>{let{dataType:n,dims:o,download:r,dispose:a}=t;return new L({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:o,download:r,dispose:a})},bt=(e,t,n)=>new L({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})});var z,ne,Tt,St,At=E(()=>{"use strict";z=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ne=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Tt=!1,St=()=>{if(!Tt){Tt=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;e&&(z.set("int64",BigInt64Array),ne.set(BigInt64Array,"int64")),t&&(z.set("uint64",BigUint64Array),ne.set(BigUint64Array,"uint64")),n?(z.set("float16",Float16Array),ne.set(Float16Array,"float16")):z.set("float16",Uint16Array)}}});var Ot,xt,vt=E(()=>{"use strict";we();Ot=e=>{let t=1;for(let n=0;n<e.length;n++){let o=e[n];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${n}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${o}`);t*=o}return t},xt=(e,t)=>{switch(e.location){case"cpu":return new L(e.type,e.data,t);case"cpu-pinned":return new L({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new L({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new L({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new L({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var L,we=E(()=>{"use strict";mt();Et();At();vt();L=class{constructor(t,n,o){St();let r,a;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,r=t.type,a=t.dims,t.location){case"cpu-pinned":{let i=z.get(r);if(!i)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(t.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=t.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof t=="string")if(r=t,u=o,t==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");i=n}else{let f=z.get(t);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t==="float16"&&f===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${f.name} as data.`);t==="uint64"||t==="int64"?i=f.from(n,BigInt):i=f.from(n)}else if(n instanceof f)i=n;else if(n instanceof Uint8ClampedArray)if(t==="uint8")i=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${r} tensor's data must be type of ${f}`)}else if(u=n,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof t[0];if(f==="string")r="string",i=t;else if(f==="boolean")r="bool",i=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(t instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(t);else{let f=ne.get(t.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=f,i=t}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");a=u,this.cpuData=i,this.dataLocation="cpu"}let s=Ot(a);if(this.cpuData&&s!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=s}static async fromImage(t,n){return ht(t,n)}static fromTexture(t,n){return yt(t,n)}static fromGpuBuffer(t,n){return wt(t,n)}static fromMLTensor(t,n){return gt(t,n)}static fromPinnedBuffer(t,n,o){return bt(t,n,o)}toDataURL(t){return lt(this,t)}toImageData(t){return pt(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return xt(this,t)}}});var _,He=E(()=>{"use strict";we();_=L});var It,Lt,j,H,Ve=E(()=>{"use strict";ze();It=(e,t)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${e}::ORT::${t}`)},Lt=(e,t)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let r=0;r<n.length;r++){if(o&&!n[r].includes("TRACE_FUNC")){let a=`FUNC_${e}::${n[r].trim().split(" ")[1]}`;t&&(a+=`::${t}`),It("CPU",a);return}n[r].includes("TRACE_FUNC")&&(o=!0)}},j=e=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Lt("BEGIN",e)},H=e=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Lt("END",e)}});var ge,Ct=E(()=>{"use strict";Ge();He();Ve();ge=class e{constructor(t){this.handler=t}async run(t,n,o){j();let r={},a={};if(typeof t!="object"||t===null||t instanceof _||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof _)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let f of n){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);r[f]=null}if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,l=Object.getOwnPropertyNames(n);for(let d of this.outputNames)if(l.indexOf(d)!==-1){let c=n[d];(c===null||c instanceof _)&&(f=!0,s=!1,r[d]=c)}if(f){if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else a=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof t[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(s)for(let f of this.outputNames)r[f]=null;let i=await this.handler.run(t,r,a),u={};for(let f in i)if(Object.hasOwnProperty.call(i,f)){let l=i[f];l instanceof _?u[f]=l:u[f]=new _(l.type,l.data,l.dims)}return H(),u}async release(){return this.handler.dispose()}static async create(t,n,o,r){j();let a,s={};if(typeof t=="string"){if(a=t,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(a=t,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let l=t,d=0,c=t.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(d=n,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(c=t.byteLength-d,typeof o=="number"){if(c=o,!Number.isSafeInteger(c))throw new RangeError("'byteLength' must be an integer.");if(c<=0||d+c>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-d}].`);if(typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(l,d,c)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,u]=await it(s),f=await i.createInferenceSessionHandler(a,u);return H(),new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Tr,Pt=E(()=>{"use strict";Ct();Tr=ge});var Bt=E(()=>{"use strict"});var Mt=E(()=>{"use strict"});var Ut=E(()=>{"use strict"});var Dt=E(()=>{"use strict"});var Ye={};$e(Ye,{InferenceSession:()=>Tr,TRACE:()=>It,TRACE_FUNC_BEGIN:()=>j,TRACE_FUNC_END:()=>H,Tensor:()=>_,env:()=>S,registerBackend:()=>re});var V=E(()=>{"use strict";at();dt();Pt();He();Bt();Mt();Ve();Ut();Dt()});var be=E(()=>{"use strict"});var Ft={};$e(Ft,{default:()=>Sr});var _t,kt,Sr,Nt=E(()=>{"use strict";qe();Y();oe();_t="ort-wasm-proxy-worker",kt=globalThis.self?.name===_t;kt&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":Ee(n.wasm).then(()=>{Te(n).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:r}=n;Se(r,o).then(()=>{postMessage({type:t})},a=>{postMessage({type:t,err:a})});break}case"copy-from":{let{buffer:o}=n,r=se(o);postMessage({type:t,out:r});break}case"create":{let{model:o,options:r}=n;Ae(o,r).then(a=>{postMessage({type:t,out:a})},a=>{postMessage({type:t,err:a})});break}case"release":Oe(n),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:r,inputs:a,outputIndices:s,options:i}=n;xe(o,r,a,s,new Array(s.length).fill(null),i).then(u=>{u.some(f=>f[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:u},Ie([...a,...u]))},u=>{postMessage({type:t,err:u})});break}case"end-profiling":ve(n),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}});Sr=kt?null:e=>new Worker(e??D,{type:"module",name:_t})});var D,Ar,$t,Or,xr,Gt,vr,Wt,zt,jt,oe=E(()=>{"use strict";be();D=!1?void 0:import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Ar=!1||typeof location>"u"?void 0:location.origin,$t=(e,t)=>{try{let n=t??D;return(n?new URL(e,n):new URL(e)).origin===Ar}catch{return!1}},Or=(e,t)=>{let n=t??D;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},xr=(e,t)=>`${t??"./"}${e}`,Gt=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},vr=async e=>(await import(/*webpackIgnore:true*/e)).default,Wt=(Nt(),st(Ft)).default,zt=async()=>{if(!D)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if($t(D))return[void 0,Wt()];let e=await Gt(D);return[e,Wt(e)]},jt=async(e,t,n)=>{{let o="ort-wasm-simd-threaded.mjs",r=e??Or(o,t),a=!!1&&n&&r&&!$t(r,t),s=a?await Gt(r):r??xr(o,t);return[a?s:void 0,await vr(s)]}}});var Je,Xe,Le,Ht,Ir,Lr,Ee,x,Y=E(()=>{"use strict";oe();Xe=!1,Le=!1,Ht=!1,Ir=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lr=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ee=async e=>{if(Xe)return Promise.resolve();if(Le)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ht)throw new Error("previous call to 'initializeWebAssembly()' failed.");Le=!0;let t=e.initTimeout,n=e.numThreads;if(!Lr())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=Ir();n>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a=typeof r=="string"?r:void 0,s=r?.mjs,i=s?.href??s,u=r?.wasm,f=u?.href??u,l=e.wasmBinary,[d,c]=await jt(i,a,n>1),p=!1,w=[];if(t>0&&w.push(new Promise(m=>{setTimeout(()=>{p=!0,m()},t)})),w.push(new Promise((m,y)=>{let A={numThreads:n};l?A.wasmBinary=l:(f||a)&&(A.locateFile=(h,g)=>f??(a??g)+h),c(A).then(h=>{Le=!1,Xe=!0,Je=h,m(),d&&URL.revokeObjectURL(d)},h=>{Le=!1,Ht=!0,y(h)})})),await Promise.race(w),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},x=()=>{if(Xe&&Je)return Je;throw new Error("WebAssembly is not initialized yet.")}});var v,ie,T,Ce=E(()=>{"use strict";Y();v=(e,t)=>{let n=x(),o=n.lengthBytesUTF8(e)+1,r=n._malloc(o);return n.stringToUTF8(e,r,o),t.push(r),r},ie=(e,t,n,o)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,a])=>{let s=t?t+r:r;if(typeof a=="object")ie(a,s+".",n,o);else if(typeof a=="string"||typeof a=="number")o(s,a.toString());else if(typeof a=="boolean")o(s,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},T=e=>{let t=x(),n=t.stackSave();try{let o=t.PTR_SIZE,r=t.stackAlloc(2*o);t._OrtGetLastError(r,r+o);let a=Number(t.getValue(r,o===4?"i32":"i64")),s=t.getValue(r+o,"*"),i=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}});var Vt,Yt=E(()=>{"use strict";Y();Ce();Vt=e=>{let t=x(),n=0,o=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=v(e.tag,o)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&T("Can't create run options."),e?.extra!==void 0&&ie(e.extra,"",new WeakSet,(s,i)=>{let u=v(s,o),f=v(i,o);t._OrtAddRunConfigEntry(n,u,f)!==0&&T(`Can't set a run config entry: ${s} - ${i}.`)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),o.forEach(s=>t._free(s)),a}}});var Cr,Pr,Br,Mr,qt,Jt=E(()=>{"use strict";Y();Ce();Cr=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Pr=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Br=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},Mr=(e,t,n)=>{for(let o of t){let r=typeof o=="string"?o:o.name;switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let i=o?.deviceType;if(i){let u=v("deviceType",n),f=v(i,n);x()._OrtAddSessionConfigEntry(e,u,f)!==0&&T(`Can't set a session config entry: 'deviceType' - ${i}.`)}}break;case"webgpu":if(r="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let i=v("preferredLayout",n),u=v(s.preferredLayout,n);x()._OrtAddSessionConfigEntry(e,i,u)!==0&&T(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=v(r,n);x()._OrtAppendExecutionProvider(e,a)!==0&&T(`Can't append execution provider: ${r}.`)}},qt=e=>{let t=x(),n=0,o=[],r=e||{};Br(r);try{let a=Cr(r.graphOptimizationLevel??"all"),s=Pr(r.executionMode??"sequential"),i=typeof r.logId=="string"?v(r.logId,o):0,u=r.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let l=typeof r.optimizedModelFilePath=="string"?v(r.optimizedModelFilePath,o):0;if(n=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,i,u,f,l),n===0&&T("Can't create session options."),r.executionProviders&&Mr(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let d=v("enableGraphCapture",o),c=v(r.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(n,d,c)!==0&&T(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[d,c]of Object.entries(r.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let p=v(d,o);t._OrtAddFreeDimensionOverride(n,p,c)!==0&&T(`Can't set a free dimension override: ${d} - ${c}.`)}return r.extra!==void 0&&ie(r.extra,"",new WeakSet,(d,c)=>{let p=v(d,o),w=v(c,o);t._OrtAddSessionConfigEntry(n,p,w)!==0&&T(`Can't set a session config entry: ${d} - ${c}.`)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&T("Can't release session options."),o.forEach(s=>t._free(s)),a}}});var ae,Xt,ue,Zt,Kt,Pe,Be,Qt,Ze=E(()=>{"use strict";ae=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Xt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},ue=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],o=typeof t=="number"?t:t.reduce((r,a)=>r*a,1);return n>0?Math.ceil(o*n):void 0},Zt=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Kt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Pe=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Be=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Qt=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var fe,Ke=E(()=>{"use strict";be();fe=async e=>{if(typeof e=="string")if(!1)try{let{readFile:t}=We("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=We("node:fs"),o=n(e),r=[];for await(let a of o)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let u=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let s=0;for(;;){let{done:i,value:u}=await r.read();if(i)break;let f=u.byteLength;new Uint8Array(a,s,f).set(u),s+=f}return new Uint8Array(a,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Ur,Te,Se,K,Dr,se,Ae,Oe,er,xe,ve,Ie,qe=E(()=>{"use strict";Yt();Jt();Ze();Y();Ce();Ke();Ur=(e,t)=>{x()._OrtInit(e,t)!==0&&T("Can't initialize onnxruntime.")},Te=async e=>{Ur(e.wasm.numThreads,Kt(e.logLevel))},Se=async(e,t)=>{},K=new Map,Dr=e=>{let t=x(),n=t.stackSave();try{let o=t.PTR_SIZE,r=t.stackAlloc(2*o);t._OrtGetInputOutputCount(e,r,r+o)!==0&&T("Can't get session input/output count.");let s=o===4?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+o,s))]}finally{t.stackRestore(n)}},se=e=>{let t=x(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Ae=async(e,t)=>{let n,o,r=x();Array.isArray(e)?[n,o]=e:e.buffer===r.HEAPU8.buffer?[n,o]=[e.byteOffset,e.byteLength]:[n,o]=se(e);let a=0,s=0,i=0,u=[],f=[],l=[];try{if([s,u]=qt(t),t?.externalData&&r.mountExternalData){let h=[];for(let g of t.externalData){let O=typeof g=="string"?g:g.path;h.push(fe(typeof g=="string"?g:g.data).then(B=>{r.mountExternalData(O,B)}))}await Promise.all(h)}for(let h of t?.executionProviders??[])if((typeof h=="string"?h:h.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof h!="string"){let O=h,B=O?.context,de=O?.gpuDevice,le=O?.deviceType,pe=O?.powerPreference;B?r.currentContext=B:de?r.currentContext=await r.jsepCreateMLContext(de):r.currentContext=await r.jsepCreateMLContext({deviceType:le,powerPreference:pe})}else r.currentContext=await r.jsepCreateMLContext();break}a=await r._OrtCreateSession(n,o,s),a===0&&T("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[d,c]=Dr(a),p=!!t?.enableGraphCapture,w=[],m=[],y=[];for(let h=0;h<d;h++){let g=r._OrtGetInputName(a,h);g===0&&T("Can't get an input name."),f.push(g),w.push(r.UTF8ToString(g))}for(let h=0;h<c;h++){let g=r._OrtGetOutputName(a,h);g===0&&T("Can't get an output name."),l.push(g);let O=r.UTF8ToString(g);m.push(O)}let A=null;return K.set(a,[a,f,l,A,p,!1]),[a,w,m]}catch(d){throw f.forEach(c=>r._OrtFree(c)),l.forEach(c=>r._OrtFree(c)),i!==0&&r._OrtReleaseBinding(i)!==0&&T("Can't release IO binding."),a!==0&&r._OrtReleaseSession(a)!==0&&T("Can't release session."),d}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s)!==0&&T("Can't release session options."),u.forEach(d=>r._free(d)),r.unmountExternalData?.()}},Oe=e=>{let t=x(),n=K.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,r,a,s,i]=n;s&&(i&&t._OrtClearBoundOutputs(s.handle)!==0&&T("Can't clear bound outputs."),t._OrtReleaseBinding(s.handle)!==0&&T("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),r.forEach(u=>t._OrtFree(u)),a.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(o)!==0&&T("Can't release session."),K.delete(e)},er=(e,t,n,o,r,a=!1)=>{if(!e){t.push(0);return}let s=x(),i=s.PTR_SIZE,u=e[0],f=e[1],l=e[3],d,c;if(u==="string"&&(l==="gpu-buffer"||l==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&l!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(l==="gpu-buffer"){let m=e[2].gpuBuffer;c=ue(ae(u),f);let y=s.jsepRegisterBuffer;if(!y)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');d=y(o,r,m,c)}else if(l==="ml-tensor"){let m=e[2].mlTensor;c=ue(ae(u),f);let y=s.jsepRegisterMLTensor;if(!y)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');d=y(m,ae(u),f)}else{let m=e[2];if(Array.isArray(m)){c=i*m.length,d=s._malloc(c),n.push(d);for(let y=0;y<m.length;y++){if(typeof m[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.setValue(d+y*i,v(m[y],n),"*")}}else c=m.byteLength,d=s._malloc(c),n.push(d),s.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,c),d)}let p=s.stackSave(),w=s.stackAlloc(4*f.length);try{f.forEach((y,A)=>s.setValue(w+A*i,y,i===4?"i32":"i64"));let m=s._OrtCreateTensor(ae(u),d,c,w,f.length,Qt(l));m===0&&T(`Can't create tensor for input/output. session=${o}, index=${r}.`),t.push(m)}finally{s.stackRestore(p)}},xe=async(e,t,n,o,r,a)=>{let s=x(),i=s.PTR_SIZE,u=K.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let f=u[0],l=u[1],d=u[2],c=u[3],p=u[4],w=u[5],m=t.length,y=o.length,A=0,h=[],g=[],O=[],B=[],de=s.stackSave(),le=s.stackAlloc(m*i),pe=s.stackAlloc(m*i),ke=s.stackAlloc(y*i),rt=s.stackAlloc(y*i);try{s.jsepOnRunStart?.(f),[A,h]=Vt(a);for(let b=0;b<m;b++)er(n[b],g,B,e,t[b],p);for(let b=0;b<y;b++)er(r[b],O,B,e,m+o[b],p);for(let b=0;b<m;b++)s.setValue(le+b*i,g[b],"*"),s.setValue(pe+b*i,l[t[b]],"*");for(let b=0;b<y;b++)s.setValue(ke+b*i,O[b],"*"),s.setValue(rt+b*i,d[o[b]],"*");let k;k=await s._OrtRun(f,pe,le,m,rt,y,ke,A),k!==0&&T("failed to call OrtRun().");let X=[];for(let b=0;b<y;b++){let Z=Number(s.getValue(ke+b*i,"*"));if(Z===O[b]){X.push(r[b]);continue}let nt=s.stackSave(),F=s.stackAlloc(4*i),te=!1,C,M=0;try{s._OrtGetTensorData(Z,F,F+i,F+2*i,F+3*i)!==0&&T(`Can't access output tensor data on index ${b}.`);let Fe=i===4?"i32":"i64",me=Number(s.getValue(F,Fe));M=s.getValue(F+i,"*");let ot=s.getValue(F+i*2,"*"),pr=Number(s.getValue(F+i*3,Fe)),N=[];for(let P=0;P<pr;P++)N.push(Number(s.getValue(ot+P*i,Fe)));s._OrtFree(ot)!==0&&T("Can't free memory for tensor dims.");let W=N.reduce((P,I)=>P*I,1);C=Xt(me);let he=c?.outputPreferredLocations[o[b]];if(C==="string"){if(he==="gpu-buffer"||he==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let P=[];for(let I=0;I<W;I++){let $=s.getValue(M+I*i,"*"),mr=s.getValue(M+(I+1)*i,"*"),hr=I===W-1?void 0:mr-$;P.push(s.UTF8ToString($,hr))}X.push([C,N,P,"cpu"])}else if(he==="gpu-buffer"&&W>0){let P=s.jsepGetBuffer;if(!P)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let I=P(M),$=ue(me,W);if($===void 0||!Pe(C))throw new Error(`Unsupported data type: ${C}`);te=!0,X.push([C,N,{gpuBuffer:I,download:s.jsepCreateDownloader(I,$,C),dispose:()=>{s._OrtReleaseTensor(Z)!==0&&T("Can't release tensor.")}},"gpu-buffer"])}else if(he==="ml-tensor"&&W>0){let P=s.jsepEnsureTensor;if(!P)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ue(me,W)===void 0||!Be(C))throw new Error(`Unsupported data type: ${C}`);let $=await P(M,me,N,!1);te=!0,X.push([C,N,{mlTensor:$,download:s.jsepCreateMLTensorDownloader(M,C),dispose:()=>{s.jsepReleaseTensorId(M),s._OrtReleaseTensor(Z)}},"ml-tensor"])}else{let P=Zt(C),I=new P(W);new Uint8Array(I.buffer,I.byteOffset,I.byteLength).set(s.HEAPU8.subarray(M,M+I.byteLength)),X.push([C,N,I,"cpu"])}}finally{s.stackRestore(nt),C==="string"&&M&&s._free(M),te||s._OrtReleaseTensor(Z)}}return c&&!p&&(s._OrtClearBoundOutputs(c.handle)!==0&&T("Can't clear bound outputs."),K.set(e,[f,l,d,c,p,!1])),X}finally{s.stackRestore(de),g.forEach(k=>s._OrtReleaseTensor(k)),O.forEach(k=>s._OrtReleaseTensor(k)),B.forEach(k=>s._free(k)),A!==0&&s._OrtReleaseRunOptions(A),h.forEach(k=>s._free(k))}},ve=e=>{let t=x(),n=K.get(e);if(!n)throw new Error("invalid session id");let o=n[0],r=t._OrtEndProfiling(o);r===0&&T("Can't get an profile file name."),t._OrtFree(r)},Ie=e=>{let t=[];for(let n of e){let o=n[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t}});var J,R,ce,Ue,De,Me,Qe,et,Q,ee,_r,tr,rr,nr,or,sr,ir,ar,tt=E(()=>{"use strict";V();qe();Y();oe();J=()=>!!S.wasm.proxy&&typeof document<"u",ce=!1,Ue=!1,De=!1,et=new Map,Q=(e,t)=>{let n=et.get(e);n?n.push(t):et.set(e,[t])},ee=()=>{if(ce||!Ue||De||!R)throw new Error("worker not ready")},_r=e=>{switch(e.data.type){case"init-wasm":ce=!1,e.data.err?(De=!0,Qe[1](e.data.err)):(Ue=!0,Qe[0]()),Me&&(URL.revokeObjectURL(Me),Me=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=et.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},tr=async()=>{if(!Ue){if(ce)throw new Error("multiple calls to 'initWasm()' detected.");if(De)throw new Error("previous call to 'initWasm()' failed.");if(ce=!0,J())return new Promise((e,t)=>{R?.terminate(),zt().then(([n,o])=>{try{R=o,R.onerror=a=>t(a),R.onmessage=_r,Qe=[e,t];let r={type:"init-wasm",in:S};R.postMessage(r),Me=n}catch(r){t(r)}},t)});try{await Ee(S.wasm),await Te(S),Ue=!0}catch(e){throw De=!0,e}finally{ce=!1}}},rr=async e=>{if(J())return ee(),new Promise((t,n)=>{Q("init-ep",[t,n]);let o={type:"init-ep",in:{epName:e,env:S}};R.postMessage(o)});await Se(S,e)},nr=async e=>J()?(ee(),new Promise((t,n)=>{Q("copy-from",[t,n]);let o={type:"copy-from",in:{buffer:e}};R.postMessage(o,[e.buffer])})):se(e),or=async(e,t)=>{if(J()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ee(),new Promise((n,o)=>{Q("create",[n,o]);let r={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),R.postMessage(r,a)})}else return Ae(e,t)},sr=async e=>{if(J())return ee(),new Promise((t,n)=>{Q("release",[t,n]);let o={type:"release",in:e};R.postMessage(o)});Oe(e)},ir=async(e,t,n,o,r,a)=>{if(J()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return ee(),new Promise((s,i)=>{Q("run",[s,i]);let u=n,f={type:"run",in:{sessionId:e,inputIndices:t,inputs:u,outputIndices:o,options:a}};R.postMessage(f,Ie(u))})}else return xe(e,t,n,o,r,a)},ar=async e=>{if(J())return ee(),new Promise((t,n)=>{Q("end-profiling",[t,n]);let o={type:"end-profiling",in:e};R.postMessage(o)});ve(e)}});var ur,kr,Re,fr=E(()=>{"use strict";V();tt();Ze();be();Ke();ur=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},kr=e=>{switch(e[3]){case"cpu":return new _(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Pe(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=e[2];return _.fromGpuBuffer(n,{dataType:t,dims:e[1],download:o,dispose:r})}case"ml-tensor":{let t=e[0];if(!Be(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:o,dispose:r}=e[2];return _.fromMLTensor(n,{dataType:t,dims:e[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},Re=class{async fetchModelAndCopyToWasmMemory(t){return nr(await fe(t))}async loadModel(t,n){j();let o;typeof t=="string"?!1?o=await fe(t):o=await this.fetchModelAndCopyToWasmMemory(t):o=t,[this.sessionId,this.inputNames,this.outputNames]=await or(o,n),H()}async dispose(){return sr(this.sessionId)}async run(t,n,o){j();let r=[],a=[];Object.entries(t).forEach(c=>{let p=c[0],w=c[1],m=this.inputNames.indexOf(p);if(m===-1)throw new Error(`invalid input '${p}'`);r.push(w),a.push(m)});let s=[],i=[];Object.entries(n).forEach(c=>{let p=c[0],w=c[1],m=this.outputNames.indexOf(p);if(m===-1)throw new Error(`invalid output '${p}'`);s.push(w),i.push(m)});let u=r.map((c,p)=>ur(c,()=>`input "${this.inputNames[a[p]]}"`)),f=s.map((c,p)=>c?ur(c,()=>`output "${this.outputNames[i[p]]}"`):null),l=await ir(this.sessionId,a,u,i,f,o),d={};for(let c=0;c<l.length;c++)d[this.outputNames[i[c]]]=s[c]??kr(l[c]);return H(),d}startProfiling(){}endProfiling(){ar(this.sessionId)}}});var dr={};$e(dr,{OnnxruntimeWebAssemblyBackend:()=>_e,initializeFlags:()=>cr,wasmBackend:()=>Fr});var cr,_e,Fr,lr=E(()=>{"use strict";V();tt();fr();oe();cr=()=>{if((typeof S.wasm.initTimeout!="number"||S.wasm.initTimeout<0)&&(S.wasm.initTimeout=0),S.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof S.wasm.proxy!="boolean"&&(S.wasm.proxy=!1),typeof S.wasm.trace!="boolean"&&(S.wasm.trace=!1),typeof S.wasm.numThreads!="number"||!Number.isInteger(S.wasm.numThreads)||S.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)S.wasm.numThreads=1;else{let e=typeof navigator>"u"?We("node:os").cpus().length:navigator.hardwareConcurrency;S.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}S.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(S.wasm.wasmPaths=D.substring(0,D.lastIndexOf("/")+1))},_e=class{async init(t){cr(),await tr(),await rr(t)}async createInferenceSessionHandler(t,n){let o=new Re;return await o.loadModel(t,n),Promise.resolve(o)}},Fr=new _e});V();V();V();var Rt="1.21.0-dev.20241205-d27fecd3d3";var Eo=Ye;{let e=(lr(),st(dr)).wasmBackend;re("cpu",e,10),re("wasm",e,10)}Object.defineProperty(S.versions,"web",{value:Rt,enumerable:!0});export{Tr as InferenceSession,It as TRACE,j as TRACE_FUNC_BEGIN,H as TRACE_FUNC_END,_ as Tensor,Eo as default,S as env,re as registerBackend};
//# sourceMappingURL=ort.wasm.min.mjs.map
